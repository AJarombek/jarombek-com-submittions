<!DOCTYPE html>
<!-- Author: Andrew Jarombek
     Date: 12/12/2017 -->
<html>
    <head>
        <meta chartset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Creating a Node.js and MongoDB REST API Prototype</title>
        <link rel="stylesheet" href="../../../blog-discover.css">
        <link rel="stylesheet" href="style/nodejs-mongodb.css">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/fantasque-sans-mono" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" 
            integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
        <link href="../../../prism.css" rel="stylesheet" />
    </head>
    <body>
        <div class="col-md-12 discoveryBody">
            <div class="col-md-12 discoveryContent">
                <p class="date">December 30th, 2017</p>
                <br>
                <h4>Creating a Node.js and MongoDB REST API Prototype</h4>
                <br>
                <div class="container aknowledge">
                    <p>Assumed Knowledge:</p>
                    <p>MongoDB <span class="badge badge-warning">Intermediate</span></p>
                    <p>Node.js <span class="badge badge-warning">Intermediate</span></p>
                    <p>Express <span class="badge badge-warning">Intermediate</span></p>
                    <p>JavaScript <span class="badge badge-warning">Intermediate</span></p>
                    <p>REST <span class="badge badge-default">Basic</span></p>
                </div><br>
                <div id="discoveryText" class="container">
                    <p>
                        Most of my discoveries lately have been about JavaScript.   This includes learning the new ES6 syntax and features along with all the 
                        quirks that come with the JavaScript language.  Recently I have been exploring the MongoDB database and Node.js environment.  
                        MongoDB is a NoSQL database that allows you to store JSON formatted documents in a schema-less model.  I wrote four discovery 
                        posts on MongoDB starting with the 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/12-Dec/12-15-MongoDB-Pt1/View">basic features of the database</a>
                        .  While I haven't written any discoveries with Node.js as the main focus, I have experimented with it when testing out 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/11-10-ES6-Modules-Babel/View">ES6 modules with Babel</a> 
                        and 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/11-26-JS-Async-Function/View">Async Functions</a>.  
                    </p>
                    <p>
                        All of this knowledge buildup is for a personal website project that I have planned (and where this blog will call home!).  
                        Before I start development on the website directly, I will create a series of prototypes to get a feel for some of the 
                        technologies I will use in my websites stack.  With these prototypes I can make sure the technology I choose is a good fit for 
                        the full project.  Also I can use them as templates to complete future discoveries!  In general if you have the time to build 
                        prototypes with technologies you want to use in a production project it is a great idea!
                    </p>
                    <p>
                        My planned production web stacks will be either MEAN (MongoDB, Express, <strong>Angular</strong>, Node.js) or MERN (MongoDB, Express, <strong>React.js</strong>, 
                        Node.js).  You will notice that three of these technologies are present in both stacks - <strong>MongoDB, Express, and Node.js</strong>.  We will 
                        be using all three to build the prototype today!
                    </p>
                    <h5>Prototype Structure</h5>
                    <p>
                        The prototype is a REST API that lets users look at songs and artists.  They can also comment on songs.  MongoDB stores this 
                        information in a database called <code>music_api</code>.  Databases in MongoDB are simply namespaces, which is much different than 
                        their Relational Database equivalents.  In a RDBMS you need a username and password among other items to connect to a certain 
                        database.  MongoDB does not have this requirement. 
                    </p>
                    <p>
                        The data is then stored in collections of documents including songs, artists, and end users.
                    </p>
                    <figure id="mongo-image">
                        <img src="mongodb.png">
                    </figure>
                    <p>
                        The Node.js run-time environment and Express web application framework then expose a REST API to users so they can query, create, 
                        update, and delete items in the database (all CRUD operations).  
                    </p>
                    <figure id="restapi-image">
                        <img src="restapi.png">
                    </figure>
                    <p>
                        For the prototype most of the functionality surrounds viewing and manipulating songs, however in a full application the uses would 
                        be expanded.  This could include creating and updating users, rating songs, user-to-user interactivity, etc.  Now let's look at some 
                        insteresting aspects of the prototype and certain challenges that I faced while creating it.
                    </p>
                    <h5>Using Mongoose</h5>
                    <p>
                        For interacting with the MongoDB database from Node.js I chose to use a module called Mongoose.  Mongoose allows you to model database 
                        JSON objects and perform all MongoDB queries, inserts, and updates.  With MongoDB you don't really need to use a ORM (Object Relational 
                        Mapping) framework since all the data is already in JSON form which any programming language can deal with.  However, Mongoose gives us 
                        some additional capabilities which make it desirable.  
                    </p>
                    <p>
                        First of Mongoose allows you to perform set strict schema rules for your MongoDB objects.  As previously mentioned MongoDB is 
                        schema-less so this stricter model can help restrict what exactly a user can place in a document.  You can also create nested schemas 
                        for complex JSON documents.  For example, my song collection schema contains a nested schema for a list of comments.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const Schema = mongoose.Schema;
                                
const SongSchema = new Schema({
    title: {
        type: String,
        trim: true,
        required: true
    },
    album: {
        type: String,
        trim: true
    },
    artist: {
        type: String,
        trim: true,
        required: true
    },
    artist_id: Schema.Types.ObjectId,
    type: {
        type: String,
        enum: ['a', 'j', 'aj']
    },
    release_date: {
        type: Date,
        default: Date.now()
    },
    best_lyric: String,
    comments: [{
        type: CommentSchema
    }]
}, {usePushEach: true});</code>
                        </pre>
                    </figure>
                    <p>
                        You can see that each <code>Schema()</code> constructor function takes a JSON object that represents all the properties of the 
                        MongoDB document.  You can also add additional validations, such as making certain fields required (<code>required: true</code>) or 
                        having a default value (<code>default: Date.now()</code>)<sup>1</sup>.  When a user uploads a JSON object to a schema and tries updating the 
                        database, only the properties seen in the schema will be persisted to MongoDB.
                    </p>
                    <p>
                        Also there is a comments properties which takes an array of type <code>CommentSchema</code>.  This <code>CommentSchema</code> can then 
                        be defined similarly to how I implemented <code>SongSchema</code>.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const CommentSchema = new Schema({
    username: String,
    user_id: Schema.Types.ObjectId,
    date: {
        type: Date,
        default: Date.now()
    },
    content: {
        type: String,
        trim: true
    }
}, {usePushEach: true, _id : false});</code>
                        </pre>
                    </figure>
                    <p>
                        Another powerful feature of MongoDB is that we can define database indexes directly on the <code>Schema</code> object.  With features 
                        such as this one Mongoose has transformed into something much more powerful than a ORM.  With Mongoose I did not even have to go into 
                        MongoDB itself since everything I needed could be performed through Mongoose.  Here is an index I made on the <code>name</code> property
                        in the artist schema.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">ArtistSchema.index({name: 1});</code>
                        </pre>
                    </figure>
                    <h5>Switching to Promises</h5>
                    <p>
                        Mongoose allows you to perform any query, update, insert, or delete operations on a Schema.  By default however, Mongoose uses callbacks 
                        to perform these operations.  We want to avoid callbacks as they can become ugly once nested database calls need to be made (commonly 
                        known as callback hell).  Luckily Mongoose allows us to use ES6 Promises instead<sup>2</sup>.  One of the first things I did when creating my API 
                        calls was to replace all the callbacks I could with Promises.  Here is some code that performs a <code>find</code> operation on the 
                        <code>Song</code> schema and then returns it to as a HTTP response.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">Song.find().exec()
    .then((songs) => {
        res.format({
            'application/json': () => {
                res.json(songs);
            },
            'application/xml': () => {
                res.render('xml/songs', {songs: songs});
            }
        });
    })
    .catch((err) => {
        console.error(err);
        res.status(500).send(err);
    });</code>
                        </pre>
                    </figure>
                    <h5>Using EJS to Return XML</h5>
                    <p>
                        You may have noticed in that last code sample the <code>res.format()</code> function which returns the song data as an HTTP response.  
                        This function also returns either JSON or XML depending on the MIME type specified in the HTTP requests <code>Accept</code> header.  
                        Normally I wouldnâ€™t think the development work to return both notations to be worth it but Express made it so easy to implement
                        <sup>3</sup>!
                    </p>
                    <p>
                        There are two ways to implement the conversion to XML.  One option is to perform it in our JavaScript itself<sup>4</sup>.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">'application/xml': () => {
    res.write('<songs>\n');

    songs.forEach((song) => {
        let comments = "";
        song.comments.forEach((comment) => {
            comments = `
                ${comments}
                &lt;comment&gt;
                    &lt;username&gt;${comment.username}&lt;/username&gt;
                    &lt;date&gt;${comment.date}&lt;/date&gt;
                    &lt;content&gt;${comment.content}&lt;/content&gt;
                &lt;/comment&gt;
            `;
        });

        res.write(`
            &lt;entry&gt;
                &lt;title&gt;${song.title}&lt;/title&gt;
                &lt;artist&gt;${song.artist}&lt;/artist&gt;
                &lt;album&gt;${song.album}&lt;/album&gt;
                &lt;type&gt;${song.type}&lt;/type&gt;
                &lt;release_date&gt;${song.release_date}&lt;/release_date&gt;
                &lt;best_lyric&gt;${song.best_lyric}&lt;/best_lyric&gt;
                &lt;comments&gt;${comments}&lt;/comments&gt;
            &lt;/entry&gt;
        `);
    });
    res.end('&lt;/songs&gt;');
}</code>
                        </pre>
                    </figure>
                    <p>
                        This is a bit messy as you are mixing JavaScript and a markup language together.  A more elegant solution would be to use a tempting 
                        language to generate the XML.  The template language I used is EJS (embedded javascript templating) which mixes JavaScript with HTML 
                        similarly to JSP for Java or PHP (which I used in my saintsxctf.com website)<sup>5</sup>.  We then use this template to create the 
                        markup on the server using JavaScript before sending it to the client.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-html" title="EJS" contenteditable="true" spellcheck="false">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;songs&gt;
    &lt;% for (var i = 0; i &lt; songs.length; i++) { %&gt;
        &lt;song&gt;
            &lt;_id&gt;&lt;%= songs[i]._id %&gt;&lt;/_id&gt;
            &lt;title&gt;&lt;%= songs[i].title %&gt;&lt;/title&gt;
            &lt;artist&gt;&lt;%= songs[i].artist %&gt;&lt;/artist&gt;
            &lt;album&gt;&lt;%= songs[i].album %&gt;&lt;/album&gt;
            &lt;type&gt;&lt;%= songs[i].type %&gt;&lt;/type&gt;
            &lt;release_date&gt;&lt;%= songs[i].release_date %&gt;&lt;/release_date&gt;
            &lt;best_lyric&gt;&lt;%= songs[i].best_lyric %&gt;&lt;/best_lyric&gt;
            &lt;comments&gt;
                &lt;% for (var j = 0; j &lt; songs[i].comments.length; j++) { %&gt;
                    &lt;comment&gt;
                        &lt;username&gt;&lt;%= songs[i].comments[j].username %&gt;&lt;/username&gt;
                        &lt;date&gt;&lt;%= songs[i].comments[j].date %&gt;&lt;/date&gt;
                        &lt;content&gt;&lt;%= songs[i].comments[j].content %&gt;&lt;/content&gt;
                    &lt;/comment&gt;
                &lt;% } %&gt;
            &lt;/comments&gt;
        &lt;/song&gt;
    &lt;% } %&gt;
&lt;/songs&gt;</code>
                        </pre>
                    </figure>
                    <p>
                        One drawback of this approach is that all the JavaScript code I wrote in the EJS template was in ES5.  Babel is unable to 
                        transpile EJS so if you write ES6 all browsers must be ES6 compatible.  Therefore I settled for ES5 just to be safe.  Here you 
                        can see the XML result in postman:
                    </p>
                    <figure id="xmlresponse-image">
                        <img src="xmlresponse.png">
                    </figure>
                    <h5>Text Search</h5>
                    <p>

                    </p>
                    <figure>
                        <pre class="command-line" data-prompt=">" data-output="2">
                            <code class="language-bash" title="Bash" contenteditable="true" spellcheck="false">use xmas</code>
                        </pre>
                    </figure>
                    <div class="container tags">
                        <p>
                            Tags: <span class="badge badge-default">MongoDB</span> <span class="badge badge-default">Node.js</span> <span class="badge badge-default">Express</span>
                            <span class="badge badge-default">JavaScript</span> <span class="badge badge-default">ECMAScript 6</span> <span class="badge badge-default">NoSQL</span> <span class="badge badge-default">Document Database</span>
                            <span class="badge badge-default">Mongoose</span> <span class="badge badge-default">Babel</span> <span class="badge badge-default">Gulp</span> <span class="badge badge-default">REST</span>
                        </p>
                    </div>
                    <div class="container sources">
                        <p>[1] Amos Haviv, MEAN Web Development, 2nd ed (Birmingham, UK: Packt, 2016), 110</p>
                        <p>[2] "Built-in Promises", http://mongoosejs.com/docs/promises.html</p>
                        <p>[3] Alex Young, Bradley Meck, Mike Cantelon, Node.js In Action, 2nd ed (Shelter Island, NY: Manning, 2017), 156</p>
                        <p>[4] Young., 157</p>
                        <p>[5] Young., 158</p>
                    </div>
                </div>
            </div>
        </div>
        <script src="../../../prism.js"></script>
    </body>
</html>